## 写在前面
这个项目源于本学期的专业课——Java程序设计的结课作业。一般来说，大多数同学都选择直接在本地完成这个作业，然后直接打包提交。但我想，不妨趁着这个机会，好好学一学如何利用Github进行项目开发，熟悉如何从无到有地完成一个项目的搭建，同时一边做也一边记录下自己的心得体会，方便总结出一条学习路径，也给同样在学习的同学中一个参考。

事实上我们还没有开始讲网络编程的部分，这个学期的Java课就已经上完了。多线程也只是讲了一点点。所以开始之前之前，我也只不过是稍微了解了Java的基础语法和面向对象的程序设计思路。其余的部分，我打算边做边学。自己慢慢琢磨。

此前我也做过一个LSB隐写的Python小项目，但在完成那个项目时，我是首先在纸上构建好了各个模块，再分模块完成的程序本身。虽然算得上是条理清晰，但相比我了解到的大多数开发流程，似乎少了些动态的部分。于是这一次，我打算先写(或者复制？)一个大致的框架进来，不管是什么，先让这个程序跑起来。然后再在它的基础上不断添加新的feature或者完善项目的结构。或许这样能更有一砖一瓦建起高楼大厦的成就感，也希望能给看到这个的同学们带来一些启示。
<h3><center>孩子写得很用心 希望老师给个高分😘😘</center></h3>

## 开始工作！

### 功能列表
- [x] 基础的聊天室
- [x] 显示消息发送时间与来源
- [x] 图形化界面(Swing)
- [x] 用户登录与名称显示
- [x] 区分聊天室(定向转发)
### 开发日志
#### 基础的通信功能
Java的网络编程意外地简单，需要的功能几乎全都封装好了，我参照[菜鸟教程](https://www.runoob.com/java/java-networking.html)上的总结，很快就了解了大致的用法。在读懂代码之后，我直接从文章中复制粘贴了客户端与服务端简单通信的的代码并稍作修改，很快就实现了最基本的文字传输功能。(注意！Ctrl+C/V前先好好把代码读懂！)

因为客户端除了和服务端通信之外，还需要新增图形化界面等多个模块，我便将涉及Socket通信的代码单独封装成了一个类`ClientNetwork`，用于和服务器通信。在初始化时传入ip和端口，需要时直接调用相关函数对服务器收发信息。

但此时实现的功能仍然是服务器与客户端之间点对点通信，不同客户端发送的信息并不能互相可见。因此需要重构服务端代码。原版的服务端代码中使用线程池来处理多个连接，每个连接单独占用一个线程。因此要想达到聊天室的效果，需要实现线程间通信。考虑了一下两个方案：
- 主函数中使用Map来存储多个连接及其对应信息，当有一个线程收到客户端收到的信息时，从Map中取出所有当前连接并遍历，逐个发送当前接收到的消息。
- 另外创建一个控制器，单独占用一个线程用于管理所有连接。当有线程收到新的消息时，调用控制器相应的函数，由这个单独的线程发送内容到各个连接中。
综合考虑，方案二更为合适。将对不同线程中对象的写操作集中到同一个线程内，一定程度上保证了线程安全。同时也便于实现一个服务器维护多个不同的聊天室。

于是新建一个类`ServerCore`，将主函数中的线程池移动到此处，并且内置一个HashSet `connections`，用来存储当前活跃的线程信息。当有新的连接接入时，主函数调用该类的`newThread()`函数并传入socket信息，由它来指定线程运行任务，并将当前线程信息存入HashSet中。
当有连接断开时，由负责处理该连接的线程调用`SeverCore`类的静态方法`deleteThread`，从而从HashSet中删除这一线程信息。具体的实现在`ServerHandler`中。
美中不足的是在处理连接断开时是从各个线程调用`SeverCore`的，因此也将`SeverCore`写成了静态类。但并没有解决这一问题的更好方法，总之先这么写着……

至此就已经能够实现基础的通信和群聊功能了。但还有一个很明显的bug：客户端在接受消息之前，必须先完成发送消息的动作。这是因为在运行程序时，客户端无操作时总是停留在等待消息输入的阶段，不能第一时间把收到的消息打印到屏幕上。要解决这个问题，只能使用图形化界面，将聊天框和输入框区分开。

此时项目源文件的目录结构如下：
```
└─src
    ├─client
    │      ChatroomClient.java
    │      ClientNetwork.java
    │      
    └─server
            ChatroomServer.java
            ServerCore.java
            ServerHandler.java
```
- client部分
	- `ChatroomClient`: 客户端主程序，启动后尝试连接服务器。
	- `ClientNetwork`: 用于与服务器之间通信，收发消息。
- server部分
	- `ChatroomServer`: 服务器主程序，启动后监听目标端口，并在收到连接后调用Core，创建新的线程。
	- `ServerCore`: 用于管理活跃的多个连接，并且将收到的消息转发到所有连接。
	- `ServerHandler`: 用于实现通信的单个的线程实现。
#### 显示消息时间与来源
消息来源用户、时间与内容的相匹配是一个问题。但是单纯的字符串似乎并不能胜任这一工作。最方便的方法是直接传输一个对象，包含时间、用户id、消息等属性。于是考虑设计一个可以被序列化的、包含上述信息的类，方便在网络上传输。
同时不妨让在连接时也在SeverCore中登记各个连接的用户ID等信息，便于后期验证等操作。

于是设计了一个Message类，用于承载各种在服务端与客户端之间通信的消息。同时重写了`ClientNetwork`和`ServerHandler`类中关于通信的方法，将用于读写字符串的`Reader`, `Writer`等对象替换为了用于收发对象(序列化/反序列化)的`ObjectInputStream`/`ObjectOutputStream`.

编码过程中值得注意的一个问题是，`ObjectInputStream`的构造函数在调用过程中会一直等待其传入流中出现数据，然后才会完成构造。
> ObjectInputStream是Java中用于反序列化对象的类。在使用ObjectInputStream读取对象之前，需要先读取并验证序列化流的头部。该头部包含了一些关于序列化流的元数据信息。当调用ObjectInputStream的构造函数时，如果相应的ObjectOutputStream已经将头部写入并刷新到流中，那么构造函数将会立即返回。否则，它将会阻塞等待，直到头部可用为止。这样确保了在读取对象之前，序列化流的头部已经准备好了。

因此在双方建立连接之后需要互相向对方发送一个对象，使其完成ObjectInputStream对象的构造。

此时又遇到了一个bug：将传送消息的方式改为Message的对象之后，无论发送了多少条消息，最终服务器接收到的都只是第一条消息的内容重复n次。经过debug发现，在发送之前，客户端Message对象内的内容都是正确的，但服务器每次接收的都是相同的内容。因此问题出在`ObjectInputStream`的`writeObject`方法上。
经过检查发现，客户端每次发送消息时，都没有使用新的Message对象，而是在原基础上对内含的字符串等内容进行了修改。可能是这一因素，导致`writeObject`将其识别为了同一对象，并再次发送之前就已经发送过了的内容。
修改客户端代码，使得每次发送消息都新建一个Message对象后，问题解决。

#### 图形化界面
关于GUI的设计，我脑子里并没有太多存货，也不知道都有些什么架构，索性也直接从网络上学习相关库的用法，然后写一个类附加到客户端里面。不过这样就出现了一个问题：**图形化界面的运行是直接放在主函数里，还是另外开一个线程，专门用来处理GUI相关内容？**

隐隐约约记得有一个设计原则就是通过GUI触发的所有事件，一般都单独放在线程中运行，以免图形化界面因运行任务而卡顿。
既然如此，那不如把GUI单独放在一个线程中，等待用户对其进行操作。与此同时主函数负责在GUI和网络模块之间传递消息。这样子可以避免因为等待某一项IO操作，主线程进入阻塞状态，影响了GUI的及时响应。

于是新增一个类`ClientGUI`，在类中实现了窗口的主体，包括消息框、聊天框和发送按钮。同时对外设立方法`displayMessage()`，主函数在循环中可以调用该方法，传入消息，将其发送到GUI的消息框。

发送消息的操作则与按下发送按钮的事件进行了绑定。同时在主类`ChatClient`中新增了一个静态方法`sendMessage()`，负责调用当前连接`connection`的同名方法。于是在按下按钮时，负责GUI的线程就能过通过调用主类下的方法将消息传送并发出。

同时我意识到上述新建窗口、新建按钮、绑定事件等操作并不需要自行放置到一个线程中单独运行。这段代码是一次性的，只在窗口创建的时候运行。窗口的维护、点击事件的产生等工作，Java内部会有单独的线程进行维护。因此我只需要将上述代码放在`init()`中，在主函数执行初始化时运行一次即可。

由于发送消息的操作由维持GUI的线程负责，因此在收发消息时不用担心程序因阻塞而卡在某一步的问题。但这样的问题还是在退出窗口时出现了。`ClientGUI`中设置了一个方法`getWindowStatus()`，用于检测窗口的可见性。主函数在循环中调用该方法，在检测到窗口被关闭后，终止循环并退出程序。然而主函数会被阻塞在用来接收消息的`connection.readMessage()`处，不能够及时检测到窗口的关闭。因此仍然需要两个线程，分别负责接收消息并打印到屏幕上，以及检测程序的运行。

在这之后经过反复调试，修复了至少5个大大小小的bug，多半和多线程有关，在此就不赘述了。

不过其中还是有一个非常值得思考的bug：
在完成GUI界面的开发之后，每次运行客户端时，服务端负责连接的线程总会在客户端发送完一条消息后自动断开，并抛出`EOFException`，从而导致连接被迫中断。
在ServerHandler中对于监听客户端所发送到的消息是，我原本的写法如下：
```java
while(true){
	if((nowMessage = (Message)receiver.readObject()) == null){
		break;
	}
	System.out.println("[Handler:"+userInfo.userName+"]收到消息："+nowMessage.content);
	ServerCore.forward(nowMessage);
}
```
在修改完bug后，改为了如下形式：
```java
while(true){
	if(receiveStream.available() > 0) {
		nowMessage = (Message)receiver.readObject();
		System.out.println("[Handler:"+userInfo.userName+"]收到消息："+nowMessage.content);
		if(nowMessage.status==150)
			break;
		resetTimer();
		ServerCore.forward(nowMessage);
	}
}
```

可以看到为了修复这个bug新增了很多内容。
经过分析，原来是`ObjectInputStream`流的`readObject()`方法在运行时读取到空内容的时候，并不进入阻塞状态并等待，而是会直接抛出EOFException。于是程序无法进行下去。

为了修复这个问题，我在使用`readObject()`读取消息前增加了一个判断机制，若来自socket的InputStream流`receiveStream`中存在内容，才进行读入操作。
同时也完善了退出逻辑，此前的退出完全就是个玄学操作，经常伴随着一大堆错误，说不清是因为报错而停止还是因为停止而报错……
首先是在客户端退出时，会向服务端发送一个包含`status=150`的消息，然后再关闭连接；而服务端在接收到这个消息后也会执行关闭连接与线程的相关操作。同时在服务端线程中增加了一个计时器`Timer`对象，当超过5分钟没有收到新消息后，服务端判断该连接超时，并关闭连接。若收到了一条消息，则通过`resetTimer()`方法重置计时器。

当然这里有一处逻辑缺陷，毕竟持续5分钟不发送消息还是一个比较常见的操作，加上这个功能后将对部分聊天潜水党非常不友好（笑
不过这样写的好处是避免客户端无故中断连接且没有发送中断连接的请求，导致服务器资源一直被占用。

那为什么之前在没有加GUI界面的时候没有出现这个bug呢？经过排查，原来是在之前的代码中，不管有没有消息发出，发送消息的动作都处于一个循环中，保证始终有消息发出（可能是空对象），而改为GUI之后，发送消息成为了按键触发的一个事件，于是服务端就会遇到读取空内容的情况。
不过这样解释似乎也不太说得通，例如：之前的情况下结束客户端，为什么服务端能准确地读到一个null并退出？客户端在未发送消息的时候，不是一直阻塞在读入状态吗，为什么此时不会导致服务端循环读到空内容？这些问题就留给感兴趣的朋友去思考了，总之在新的版本中，已经通过上述多个机制规避了这种问题，也完善了中断连接并退出程序的逻辑。~~急着交作业没时间思考了嘿嘿嘿~~

#### 聊天室区分、用户区分
这个相对前面的功能来说，简单了很多。

聊天室功能：仿造User类创建了一个Room类，在客户端连接和发送消息时一并序列化发送到服务端。每个User对象和Room对象都会根据其构造时的内容生成一个独特的HashCode，其中User对象在生成Hash值时使用了时间+用户名来生成，以确保唯一性。
在服务端对消息进行转发时，则会比对各个连接中所含Room对象的HashCode，只有当两者值相同时才会进行转发，从而达到了区分不同聊天室的目的。

在客户端启动时，则调用了`JOptionPane.showInputDialog()`方法向用户询问服务器地址、端口、用户名、房间名等信息。

## 后记
到这里，这个简单且简陋的聊天程序就完成了。最终，项目源文件的目录如下：
```
└─src
    ├─client
    │      ChatroomClient.java
    │      ClientGUI.java
    │      ClientNetwork.java
    │
    ├─server
    │      ChatroomServer.java
    │      ServerCore.java
    │      ServerHandler.java
    │
    └─shared
            Message.java
            Room.java
            User.java
```

说是简单，其实在很多细节的打磨上都费了心思，~~尽量不让别人看到程序有明显的bug~~，在没有进行系统测试的情况下做到这个程度，我已经很满足了。因此尽管它的功能很单一，我从中还是学到了很多。尤其是和多线程、线程安全有关的部分。如何同时处理多个任务是一门很深的学问。
目前，我并不能说得上是精通Java，但至少现在已经能够熟练使用Java写出一个还算像样的程序了，遇到问题也知道如何着手解决。（注：ChatGPT在解决编程基础问题上真的非常好用，省去了查阅文档的很多时间！）
同时经过这次工作，也掌握了很多修bug调代码的技巧。写C++程序的时候还没什么感觉，在写Java程序的时候一定不能忽视调试功能发挥的巨大作用。极大提升了找到bug的速度。
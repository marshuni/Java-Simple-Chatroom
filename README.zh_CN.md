## 写在前面
这个项目源于本学期的专业课——Java程序设计的结课作业。一般来说，大多数同学都选择直接在本地完成这个作业，然后直接打包提交。但我想，不妨趁着这个机会，好好学一学如何利用Github进行项目开发，熟悉如何从无到有地完成一个项目的搭建，同时一边做也一边记录下自己的心得体会，方便总结出一条学习路径，也给同样在学习的同学中一个参考。

事实上我们还没有开始讲网络编程的部分，这个学期的Java课就已经上完了。多线程也只是讲了一点点。所以开始之前之前，我也只不过是稍微了解了Java的基础语法和面向对象的程序设计思路。其余的部分，我打算边做边学。自己慢慢琢磨。

此前我也做过一个LSB隐写的Python小项目，但在完成那个项目时，我是首先在纸上构建好了各个模块，再分模块完成的程序本身。虽然算得上是条理清晰，但相比我了解到的大多数开发流程，似乎少了些动态的部分。于是这一次，我打算先写(或者复制？)一个大致的框架进来，不管是什么，先让这个程序跑起来。然后再在它的基础上不断添加新的feature或者完善项目的结构。或许这样能更有一砖一瓦建起高楼大厦的成就感，也希望能给看到这个的同学们带来一些启示。

## 开始工作！

### 功能列表
- [x] 基础的聊天室
- [x] 显示消息发送时间与来源
- [ ] 图形化界面(Swing)
- [ ] 区分聊天室(定向转发)
- [ ] 用户登录与名称显示(数据库存储)
- [ ] 文件传输

### 开发日志
#### 基础的通信功能
Java的网络编程意外地简单，需要的功能几乎全都封装好了，我参照[菜鸟教程](https://www.runoob.com/java/java-networking.html)上的总结，很快就了解了大致的用法。在读懂代码之后，我直接从文章中复制粘贴了客户端与服务端简单通信的的代码并稍作修改，很快就实现了最基本的文字传输功能。(注意！Ctrl+C/V前先好好把代码读懂！)

因为客户端除了和服务端通信之外，还需要新增图形化界面等多个模块，我便将涉及Socket通信的代码单独封装成了一个类`ClientNetwork`，用于和服务器通信。在初始化时传入ip和端口，需要时直接调用相关函数对服务器收发信息。

但此时实现的功能仍然是服务器与客户端之间点对点通信，不同客户端发送的信息并不能互相可见。因此需要重构服务端代码。原版的服务端代码中使用线程池来处理多个连接，每个连接单独占用一个线程。因此要想达到聊天室的效果，需要实现线程间通信。考虑了一下两个方案：
- 主函数中使用Map来存储多个连接及其对应信息，当有一个线程收到客户端收到的信息时，从Map中取出所有当前连接并遍历，逐个发送当前接收到的消息。
- 另外创建一个控制器，单独占用一个线程用于管理所有连接。当有线程收到新的消息时，调用控制器相应的函数，由这个单独的线程发送内容到各个连接中。
综合考虑，方案二更为合适。将对不同线程中对象的写操作集中到同一个线程内，一定程度上保证了线程安全。同时也便于实现一个服务器维护多个不同的聊天室。

于是新建一个类`ServerCore`，将主函数中的线程池移动到此处，并且内置一个HashSet `connections`，用来存储当前活跃的线程信息。当有新的连接接入时，主函数调用该类的`newThread()`函数并传入socket信息，由它来指定线程运行任务，并将当前线程信息存入HashSet中。
当有连接断开时，由负责处理该连接的线程调用`SeverCore`类的静态方法`deleteThread`，从而从HashSet中删除这一线程信息。具体的实现在`ServerHandler`中。
美中不足的是在处理连接断开时是从各个线程调用`SeverCore`的，因此也将`SeverCore`写成了静态类。但并没有解决这一问题的更好方法，总之先这么写着……

至此就已经能够实现基础的通信和群聊功能了。但还有一个很明显的bug：客户端在接受消息之前，必须先完成发送消息的动作。这是因为在运行程序时，客户端无操作时总是停留在等待消息输入的阶段，不能第一时间把收到的消息打印到屏幕上。要解决这个问题，只能使用图形化界面，将聊天框和输入框区分开。

此时项目源文件的目录结构如下：
```
└─src
    ├─client
    │      ChatroomClient.java
    │      ClientNetwork.java
    │      
    └─server
            ChatroomServer.java
            ServerCore.java
            ServerHandler.java
```
- client部分
	- `ChatroomClient`: 客户端主程序，启动后尝试连接服务器。
	- `ClientNetwork`: 用于与服务器之间通信，收发消息。
- server部分
	- `ChatroomServer`: 服务器主程序，启动后监听目标端口，并在收到连接后调用Core，创建新的线程。
	- `ServerCore`: 用于管理活跃的多个连接，并且将收到的消息转发到所有连接。
	- `ServerHandler`: 用于实现通信的单个的线程实现。
#### 显示消息时间与来源
消息来源用户、时间与内容的相匹配是一个问题。但是单纯的字符串似乎并不能胜任这一工作。最方便的方法是直接传输一个对象，包含时间、用户id、消息等属性。于是考虑设计一个可以被序列化的、包含上述信息的类，方便在网络上传输。
同时不妨让在连接时也在SeverCore中登记各个连接的用户ID等信息，便于后期验证等操作。

于是设计了一个Message类，用于承载各种在服务端与客户端之间通信的消息。同时重写了`ClientNetwork`和`ServerHandler`类中关于通信的方法，将用于读写字符串的`Reader`, `Writer`等对象替换为了用于收发对象(序列化/反序列化)的`ObjectInputStream`/`ObjectOutputStream`.

编码过程中值得注意的一个问题是，`ObjectInputStream`的构造函数在调用过程中会一直等待其传入流中出现数据，然后才会完成构造。
> ObjectInputStream是Java中用于反序列化对象的类。在使用ObjectInputStream读取对象之前，需要先读取并验证序列化流的头部。该头部包含了一些关于序列化流的元数据信息。当调用ObjectInputStream的构造函数时，如果相应的ObjectOutputStream已经将头部写入并刷新到流中，那么构造函数将会立即返回。否则，它将会阻塞等待，直到头部可用为止。这样确保了在读取对象之前，序列化流的头部已经准备好了。

因此在双方建立连接之后需要互相向对方发送一个对象，使其完成ObjectInputStream对象的构造。

此时又遇到了一个bug：将传送消息的方式改为Message的对象之后，无论发送了多少条消息，最终服务器接收到的都只是第一条消息的内容重复n次。经过debug发现，在发送之前，客户端Message对象内的内容都是正确的，但服务器每次接收的都是相同的内容。因此问题出在`ObjectInputStream`的`writeObject`方法上。
经过检查发现，客户端每次发送消息时，都没有使用新的Message对象，而是在原基础上对内含的字符串等内容进行了修改。可能是这一因素，导致`writeObject`将其识别为了同一对象，并再次发送之前就已经发送过了的内容。
修改客户端代码，使得每次发送消息都新建一个Message对象后，问题解决。